<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <title>SCATT DIY - Treinamento a Seco</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .main-content {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }
        .canvas-container {
            flex: 1;
            text-align: center;
            position: relative;
        }
        canvas {
            border: 2px solid #333;
            background: #fff;
            cursor: crosshair;
        }
        .controls-panel {
            width: 300px;
            background: #f8f8f8;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #555;
            font-size: 16px;
        }
        button {
            padding: 12px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background: #0056b3;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status-ready {
            background: #d4edda;
            color: #155724;
        }
        .status-calibrating {
            background: #fff3cd;
            color: #856404;
        }
        .status-error {
            background: #f8d7da;
            color: #721c24;
        }
        .stats {
            background: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .stats-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .score-display {
            font: 20px;
            font-weight: bold;
            text-align: center;
            padding: 15px;
            background: #007bff;
            color: white;
            border-radius: 5px;
            margin: 10px 0;
        }
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        }
        .connected {
            background: #28a745;
            color: white;
        }
        .disconnected {
            background: #dc3545;
            color: white;
        }
        .shot-history {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background: white;
        }
        .shot-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        .shot-item:last-child {
            border-bottom: none;
        }
        .timer-display {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
            margin: 10px 0;
        }

        /* Camera preview small */
        #cameraPreview {
            width: 320px;
            height: 180px;
            border: 2px solid #333;
            margin: 12px auto 0 auto;
            background: #000;
        }
        .camera-label {
            font-size: 12px;
            color: #666;
            margin-top: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ SCATT DIY - Sistema de Treinamento a Seco</h1>
        
        <div class="main-content">
            <div class="canvas-container">
                <canvas id="alvo" width="600" height="600"></canvas>
                <div style="margin-top: 10px; color: #666; font-size: 12px;">
                    Escala: 1mm = 3px | Clique no alvo para zoom
                </div>

                <!-- camera preview (small) -->
                <canvas id="cameraPreview" width="320" height="180"></canvas>
                <div class="camera-label">Preview da c√¢mera (MJPEG). URL padr√£o: <code id="cameraUrlLabel">http://192.168.0.50:8080/video</code></div>
            </div>
            
            <div class="controls-panel">
                <div class="control-group">
                    <h3>üîß Calibra√ß√£o</h3>
                    <button id="btnCalibrar" class="btn-primary">Iniciar Calibra√ß√£o</button>
                    <div id="status" class="status-ready">Sistema pronto.</div>
                    <div id="roiInfo" style="font-size: 14px; color: #555;">ROI: Carregando...</div>
                </div>
                
                <div class="control-group">
                    <h3>‚è± Temporizador</h3>
                    <div class="timer-display" id="timerDisplay">00:00:00</div>
                    <button id="btnStartPause" class="btn-primary">Iniciar</button>
                    <button id="btnResetTimer" class="btn-secondary">Resetar</button>
                </div>
                
                <div class="control-group">
                    <h3>üìä Pontua√ß√£o</h3>
                    <div class="score-display" id="scoreDisplay">0 pts</div>
                    <div class="stats">
                        <div class="stats-item">
                            <span>Tiros:</span>
                            <span id="shotCount">0</span>
                        </div>
                        <div class="stats-item">
                            <span>M√©dia:</span>
                            <span id="avgScore">0.0</span>
                        </div>
                        <div class="stats-item">
                            <span>Melhor:</span>
                            <span id="bestShot">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>üéÆ A√ß√µes</h3>
                    <button id="btnLimpar" class="btn-danger">Limpar Tiros</button>
                    <button id="btnSalvar" class="btn-secondary">Salvar Sess√£o</button>
                    <button id="btnZoom" class="btn-secondary">Toggle Zoom</button>
                </div>
                
                <div class="control-group">
                    <h3>üìù Hist√≥rico</h3>
                    <div class="shot-history" id="shotHistory">
                        <div style="text-align: center; color: #999;">Nenhum tiro registrado</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="connectionStatus" class="connection-status disconnected">
        Local
    </div>

<script>
/* ===================== CONFIG ===================== */
// URL MJPEG (troque pela sua URL local)
const CAMERA_URL = "http://192.168.1.4:8080/stream.mjpeg";

// Detection threshold (fixo, conforme voc√™ pediu)
const THRESHOLD = 240;

// Rela√ß√µes e fatores (ajuste se necess√°rio)
const MM_TO_PX_RATIO = 4;      // quantos pixels da c√¢mera = 1 mm (estimativa) - ajuste conforme seu setup
const FRONTEND_PX_MM = 3;      // no seu frontend 1 mm = 3 px

// Tempo m√≠nimo entre detec√ß√µes (ms)
const DETECTION_COOLDOWN_MS = 300;

/* ===================== VARI√ÅVEIS ===================== */
const canvas = document.getElementById("alvo");
const ctx = canvas.getContext("2d");

let basePoint = null;               // usado apenas para desenhar o ponto de calibra√ß√£o (verdadeiro ou objeto)
let calibrationCamPoint = null;     // {x,y} no espa√ßo da c√¢mera preview
let pontosDisparo = [];
let totalScore = 0;
let zoomMode = false;
let zoomFactor = 1;
let zoomOffsetX = 0;
let zoomOffsetY = 0;
let timerRunning = false;
let timerSeconds = 0;
let timerInterval = null;

let cameraFrameOK = false;


// ROI circular no preview da c√¢mera
const ROI_RADIUS = 40; // px
const ROI_CENTER_X = 160; // metade dos 320px do preview
const ROI_CENTER_Y = 90;  // metade dos 180px do preview

const statusDiv = document.getElementById("status");
const btnCalibrar = document.getElementById("btnCalibrar");
const btnLimpar = document.getElementById("btnLimpar");
const btnSalvar = document.getElementById("btnSalvar");
const btnZoom = document.getElementById("btnZoom");
const scoreDisplay = document.getElementById("scoreDisplay");
const shotCount = document.getElementById("shotCount");
const avgScore = document.getElementById("avgScore");
const bestShot = document.getElementById("bestShot");
const shotHistory = document.getElementById("shotHistory");
const connectionStatus = document.getElementById("connectionStatus");
const timerDisplay = document.getElementById("timerDisplay");
const btnStartPause = document.getElementById("btnStartPause");
const btnResetTimer = document.getElementById("btnResetTimer");
const roiInfo = document.getElementById("roiInfo");
document.getElementById("cameraUrlLabel").textContent = CAMERA_URL;

let modoCalibracao = false;
let lastDetectionTime = 0;

/* Valores padr√£o do alvo (mesmos do seu script) */
const DEFAULT_ALVO_PX = {
    "7": 600,
    "8": 450,
    "9": 300,
    "10": 150,
    "X": 75
};

/* Config local (substitui o fetch /config) */
const config = {
    roi_size_mm: 80,
    roi_size_px: 320,
    roi_x: 0,
    roi_y: 0,
    alvo_virtual_px: DEFAULT_ALVO_PX,
    roi_to_target_scale: 1.0,
    frontend_px_mm: FRONTEND_PX_MM
};
roiInfo.textContent = `ROI: ${config.roi_size_mm}mm x ${config.roi_size_mm}mm (${config.roi_size_px}x${config.roi_size_px}px) @ (${config.roi_x}, ${config.roi_y})`;

/* ===================== PREVIEW DA C√ÇMERA (MJPEG) ===================== */
const camPreview = document.getElementById("cameraPreview");
const camCtx = camPreview.getContext("2d");
const camImg = new Image();
let mjpegReaderAbort = false;

// Start MJPEG by setting src to the MJPEG endpoint. Many MJPEG endpoints can be loaded as <img>.
function startMJPEG() {
    try {
        camImg.crossOrigin = "anonymous";
        camImg.src = CAMERA_URL;
        camImg.onload = () => {
            // nothing else needed; render loop will draw camImg continuously
            cameraFrameOK = true;
            console.log("MJPEG loaded");
        };
        camImg.onerror = (e) => {
            console.warn("Erro carregando MJPEG (verifique URL):", e);
            setTimeout(() => { camImg.src = CAMERA_URL; }, 1500);
        };
    } catch (e) {
        console.error("Erro ao iniciar MJPEG:", e);
    }
}

/* ===================== FUN√á√ïES DO ALVO (mantidas do seu script) ===================== */
function desenharAlvo() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    if (zoomMode) {
        ctx.scale(zoomFactor, zoomFactor);
        ctx.translate(zoomOffsetX, zoomOffsetY);
    }
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    ctx.fillStyle = "white";
    ctx.fillRect(-centerX, -centerY, canvas.width * 2, canvas.height * 2);
    
    const alvo_px = config ? config.alvo_virtual_px : DEFAULT_ALVO_PX;
    const circulos = [
        { raio: alvo_px["7"] / 2, cor: "black", pontos: 7 },
        { raio: alvo_px["8"] / 2, cor: "black", pontos: 8 },
        { raio: alvo_px["9"] / 2, cor: "black", pontos: 9 },
        { raio: alvo_px["10"] / 2, cor: "black", pontos: 10 },
        { raio: alvo_px["X"] / 2, cor: "black", pontos: "X" }
    ];
    circulos.forEach((circulo, index) => {
        ctx.strokeStyle = circulo.cor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, circulo.raio, 0, 2 * Math.PI);
        ctx.stroke();
        if (index < circulos.length - 1) {
            ctx.fillStyle = "black";
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.fillText(circulo.pontos, centerX, centerY - circulo.raio - 10);
        }
    });
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(centerX, centerY, alvo_px["X"] / 2, 0, 2 * Math.PI);
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.strokeStyle = "rgba(0,0,0,0.3)";
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(centerX - alvo_px["7"] / 2, centerY);
    ctx.lineTo(centerX + alvo_px["7"] / 2, centerY);
    ctx.moveTo(centerX, centerY - alvo_px["7"] / 2);
    ctx.lineTo(centerX, centerY + alvo_px["7"] / 2);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
}

function transformarCoord(dx, dy) {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    // scale_factor est√° dispon√≠vel no config
    return { x: centerX + dx, y: centerY + dy }; // Usar dx, dy diretamente do hit.x, hit.y
}

function plotarPontos() {
    desenharAlvo();
    ctx.save();
    if (zoomMode) {
        ctx.scale(zoomFactor, zoomFactor);
        ctx.translate(zoomOffsetX, zoomOffsetY);
    }
    if (basePoint) {
        const p = transformarCoord(0, 0);
        ctx.beginPath();
        ctx.fillStyle = "purple";
        ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    pontosDisparo.forEach((pt, index) => {
        const p = transformarCoord(pt.dx, pt.dy);
        ctx.beginPath();
        ctx.fillStyle = "red";
        ctx.arc(p.x, p.y, 7.5, 0, 2 * Math.PI);  // 15 px de di√¢metro
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.fillStyle = "white";
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.fillText(index + 1, p.x, p.y + 3);
    });
    ctx.restore();
}

function atualizarEstatisticas() {
    const numTiros = pontosDisparo.length;
    shotCount.textContent = numTiros;
    if (numTiros > 0) {
        const pontuacoes = pontosDisparo.map(pt => pt.score);
        totalScore = pontuacoes.reduce((sum, score) => sum + score, 0);
        const media = totalScore / numTiros;
        const melhor = Math.max(...pontuacoes);
        scoreDisplay.textContent = `${totalScore.toFixed(1)} pts`;
        avgScore.textContent = media.toFixed(1);
        bestShot.textContent = melhor.toFixed(1);
        atualizarHistorico();
    } else {
        scoreDisplay.textContent = "0 pts";
        avgScore.textContent = "0.0";
        bestShot.textContent = "0";
        shotHistory.innerHTML = '<div style="text-align: center; color: #999;">Nenhum tiro registrado</div>';
    }
}

function atualizarHistorico() {
    const historico = pontosDisparo.map((pt, index) => {
        return `
            <div class="shot-item">
                <span>Tiro ${index + 1}:</span>
                <span>${pt.score.toFixed(1)} pts</span>
            </div>
        `;
    }).join('');
    shotHistory.innerHTML = historico;
    shotHistory.scrollTop = shotHistory.scrollHeight;
}

function atualizarStatus(texto, classe) {
    statusDiv.textContent = texto;
    statusDiv.className = classe;
}

function salvarSessao() {
    const sessao = {
        timestamp: new Date().toISOString(),
        tiros: pontosDisparo.map(pt => ({
            dx: pt.dx,
            dy: pt.dy,
            pontos: pt.score
        })),
        totalScore: totalScore,
        numTiros: pontosDisparo.length
    };
    const blob = new Blob([JSON.stringify(sessao, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `scatt_session_${new Date().toISOString().slice(0, 10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

function formatTime(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

function updateTimer() {
    timerSeconds++;
    timerDisplay.textContent = formatTime(timerSeconds);
}

/* ===================== EVENT LISTENERS (controles) ===================== */
btnCalibrar.onclick = () => {
    if (!cameraFrameOK) {
        atualizarStatus("C√¢mera indispon√≠vel. N√£o √© poss√≠vel calibrar.", "status-error");
        return;
    }
    modoCalibracao = true;
    basePoint = null;
    pontosDisparo = [];
    atualizarStatus("Modo calibra√ß√£o: aponte o laser para o centro do alvo e aguarde.", "status-calibrating");
    btnCalibrar.disabled = true;
    plotarPontos();
    atualizarEstatisticas();
    // agora a calibra√ß√£o ser√° tratada localmente ao detectar o ponto brilhante
};

btnLimpar.onclick = () => {
    pontosDisparo = [];
    totalScore = 0;
    plotarPontos();
    atualizarEstatisticas();
};

btnSalvar.onclick = salvarSessao;

btnZoom.onclick = () => {
    zoomMode = !zoomMode;
    if (zoomMode) {
        zoomFactor = 3;
        zoomOffsetX = -100;
        zoomOffsetY = -100;
        btnZoom.textContent = "Zoom Normal";
    } else {
        zoomFactor = 1;
        zoomOffsetX = 0;
        zoomOffsetY = 0;
        btnZoom.textContent = "Zoom Centro";
    }
    plotarPontos();
};

btnStartPause.onclick = () => {
    if (timerRunning) {
        clearInterval(timerInterval);
        timerRunning = false;
        btnStartPause.textContent = "Iniciar";
    } else {
        timerInterval = setInterval(updateTimer, 1000);
        timerRunning = true;
        btnStartPause.textContent = "Pausar";
    }
};

btnResetTimer.onclick = () => {
    clearInterval(timerInterval);
    timerRunning = false;
    timerSeconds = 0;
    timerDisplay.textContent = "00:00:00";
    btnStartPause.textContent = "Iniciar";
};

/* ===================== DETEC√á√ÉO NO FRONTEND (MJPEG -> canvas) ===================== */

/**
 * detectLaserInImageData
 * percorre os pixels do ImageData (RGBA) e retorna o pixel mais brilhante
 * (usando o m√©todo antigo: brilho = max(r,g,b) e threshold fixo).
 * Retorna {x,y} em coordenadas do canvas de preview, ou null.
 */
function detectLaserInImageData(imgData, width, height) {
    const data = imgData.data;
    let maxB = -1;
    let bx = null, by = null;

    for (let i = 0; i < data.length; i += 4) {
        const idx = i / 4;
        const x = idx % width;
        const y = Math.floor(idx / width);

        // checar se est√° dentro do ROI circular
        const dx = x - ROI_CENTER_X;
        const dy = y - ROI_CENTER_Y;
        if ((dx*dx + dy*dy) > (ROI_RADIUS * ROI_RADIUS)) continue;

        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const bright = Math.max(r, g, b);

        if (bright > THRESHOLD && bright > maxB) {
            maxB = bright;
            bx = x;
            by = y;
        }
    }

    if (bx !== null) return { x: bx, y: by };
    return null;
}


/**
 * calculateScore(distance_mm)
 * fun√ß√£o simples de scoring: 10 pontos no centro, decresce com a dist√¢ncia.
 * ajuste conforme desejado.
 */
function calculateScore(distance_mm) {
    // exemplo: pontua√ß√£o linear decrescente (at√© 0)
    const score = Math.max(0, 10 - (distance_mm / 5)); // 5 mm por ponto
    return Math.round(score * 10) / 10; // 1 casa decimal
}

/* Main loop: desenha preview da c√¢mera, detecta ponto, faz calibra√ß√£o e registra tiros */
function mainLoop() {
    // draw camera preview image (camImg) into camPreview canvas

    // desenhar ROI circular
    
    
    try {
        camCtx.drawImage(camImg, 0, 0, camPreview.width, camPreview.height);
        camCtx.beginPath();
        camCtx.strokeStyle = "rgba(255,255,255,0.7)";
        camCtx.lineWidth = 2;
        camCtx.arc(ROI_CENTER_X, ROI_CENTER_Y, ROI_RADIUS, 0, Math.PI * 2);
        camCtx.stroke();
    
        // sombra interna (opcional para visual mais bonito)
        camCtx.beginPath();
        camCtx.fillStyle = "rgba(0,0,0,0.25)";
        camCtx.arc(ROI_CENTER_X, ROI_CENTER_Y, ROI_RADIUS, 0, Math.PI * 2);
        camCtx.fill();
    } catch (e) {
        // imagem possivelmente n√£o carregada ainda
    }

    // pegar pixels do preview
    const imgData = camCtx.getImageData(0, 0, camPreview.width, camPreview.height);
    const detected = detectLaserInImageData(imgData, camPreview.width, camPreview.height);
    const now = performance.now();

    if (detected && (now - lastDetectionTime > DETECTION_COOLDOWN_MS)) {
        if (modoCalibracao) {
            // grava ponto de calibra√ß√£o (nas coordenadas da c√¢mera)
            calibrationCamPoint = {
                x: detected.x - ROI_CENTER_X,
                y: detected.y - ROI_CENTER_Y
            };
            // para desenho no alvo, setamos basePoint verdadeiro (mant√©m compatibilidade)
            basePoint = { x: 0, y: 0 };
            modoCalibracao = false;
            btnCalibrar.disabled = false;
            atualizarStatus("Modo normal. Dispare para ver os impactos.", "status-ready");
        } else if (calibrationCamPoint) {
            // calcular deslocamento em px na c√¢mera
            const dx_cam_px = (detected.x - ROI_CENTER_X) - calibrationCamPoint.x;
            const dy_cam_px = (detected.y - ROI_CENTER_X) - calibrationCamPoint.y;

            // converter px_camera -> mm (usar MM_TO_PX_RATIO)
            const dx_mm = dx_cam_px / MM_TO_PX_RATIO;
            const dy_mm = dy_cam_px / MM_TO_PX_RATIO;

            // converter mm -> frontend px (alvo)
            const dx_front_px = dx_mm * FRONTEND_PX_MM;
            const dy_front_px = dy_mm * FRONTEND_PX_MM;

            // calcular dist√¢ncia em mm para scoring
            const dist_mm = Math.sqrt(dx_mm*dx_mm + dy_mm*dy_mm);

            const score = calculateScore(dist_mm);

            // push no array usado pelo seu frontend
            pontosDisparo.push({ dx: dx_front_px, dy: dy_front_px, score: score });

            if (pontosDisparo.length > 50) pontosDisparo = pontosDisparo.slice(-50);

            plotarPontos();
            atualizarEstatisticas();
        }
        lastDetectionTime = now;
    }

    // desenha indica√ß√£o de calibra√ß√£o e ponto no preview para debug
    // limpar preview borda
    camCtx.strokeStyle = "rgba(255,255,255,0.1)";
    camCtx.lineWidth = 1;
    camCtx.strokeRect(0,0,camPreview.width, camPreview.height);

    if (calibrationCamPoint) {
        camCtx.beginPath();
        camCtx.fillStyle = "yellow";
        camCtx.arc(calibrationCamPoint.x, calibrationCamPoint.y, 6, 0, Math.PI*2);
        camCtx.fill();
    }
    if (detected) {
        camCtx.beginPath();
        camCtx.fillStyle = "lime";
        camCtx.arc(detected.x, detected.y, 4, 0, Math.PI*2);
        camCtx.fill();
    }

    // redesenhar alvo (para manter consist√™ncia)
    plotarPontos();

    requestAnimationFrame(mainLoop);
}

/* ===================== START ===================== */
desenharAlvo();
atualizarEstatisticas();
startMJPEG();
requestAnimationFrame(mainLoop);

</script>
</body>
</html>
